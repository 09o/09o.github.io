<!DOCTYPE html><html lang="en-us"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>Web Crawler · 03 | Loading 09o</title><meta name="description"><meta name="generator" content="Loading 09o"><meta name="author" content="09o"><meta name="keywords" content="sjaak van den berg, svdb, bitcoin, crypto, payment, integration, bitcoins, wordpress, betaling, webshop, front end, design, ontwerp, developer"><meta name="HandheldFriendly" content="True"><meta name="MobileOptimized" content="320"><meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1,user-scalable=0"><link rel="stylesheet" type="text/css" href="/styles/screen.css"><link rel="apple-touch-icon" sizes="57x57" href="/images/apple-touch-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/images/apple-touch-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/images/apple-touch-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/images/apple-touch-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/images/apple-touch-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/images/apple-touch-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/images/apple-touch-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/images/apple-touch-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-180x180.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/images/favicon-96x96.png"><link rel="icon" type="image/png" sizes="160x160" href="/images/favicon-160x160.png"><link rel="icon" type="image/png" sizes="192x192" href="/images/favicon-192x192.png"><meta name="msapplication-TileColor" content="#121315"><meta name="msapplication-TileImage" content="/images/mstile-144x144.png"></head><body itemscope itemtype="https://schema.org/WebPage"><header itemscope itemtype="https://schema.org/WPHeader"><a href="/"><img src="/images/svdb.png" alt="Loading 09o" title="Loading 09o"></a><h1><a href="/" alt="Loading 09o" title="Loading 09o" itemprop="headline">Loading 09o</a></h1><p itemprop="description">Where there is a will, there is a way.</p><nav itemscope itemtype="https://schema.org/SiteNavigationElement"><ul><li itemprop="name"><a href="/" alt="Home" title="Home" itemprop="url">Home</a></li><li itemprop="name"><a href="/articles" alt="Articles" title="Articles" itemprop="url">Articles</a></li><li itemprop="name"><a href="/about" alt="About" title="About" itemprop="url">About</a></li></ul></nav><div class="space"></div></header><main itemscope itemtype="https://schema.org/Blog"><article class="full"><h1 itemprop="headline">Web Crawler · 03</h1><span class="post-meta">Published on<time itemprop="datePublished" datetime="2017-10-11T19:02:16.000Z"> Thursday, October 12th 2017 at 3:02</time><br>Last updated on<time itemprop="dateModified" datetime="2017-10-11T19:02:16.000Z"> Monday, October 16th 2017 at 7:05</time></span><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p><img src="http://wx1.sinaimg.cn/mw690/ee20bc6cgy1fkewndpo2gj21hc0xc1kx.jpg" alt="此处输入图片的描述"></p>
<p>正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。<br><a id="more"></a><br>正则的大致匹配过程：</p>
<ol>
<li>依次拿出表达式和文本中的字符比较；</li>
<li>如果每一个字符都能匹配，则匹配成功；一旦有匹配不成功的字符则匹配失败；</li>
<li>如果表达式中有量词或边界，这个过程会稍微有些不同；</li>
</ol>
<blockquote>
<p><strong>正则的语法规则</strong></p>
</blockquote>
<p><img src="http://wx3.sinaimg.cn/mw690/ee20bc6cgy1fkhd6g0fxsj20ua0iy0zd.jpg" alt="此处输入图片的描述"><br><img src="http://wx3.sinaimg.cn/mw690/ee20bc6cgy1fkhd6hzhkmj20vs0kqwk0.jpg" alt=""><br><img src="http://wx1.sinaimg.cn/mw690/ee20bc6cgy1fkhd6k0ptvj20vs0d0gqz.jpg" alt=""><br><img src="http://wx1.sinaimg.cn/mw690/ee20bc6cgy1fkhd6n1fnxj20vp0esn4o.jpg" alt=""></p>
<h3>相关注解</h3>

<p><strong>数量词的贪婪模式与非贪婪模式</strong><br>Python里数量词默认是贪婪的，总是尝试匹配尽可能多的字符；非贪婪模式则相反，总是尝试匹配尽可能少的字符。例如：正则 “ab*”如果用于查找”abbbc”，将找到”abbb”；而非贪婪模式会得到 “a”.<br>一般都使用非贪婪模式来提取。</p>
<p><strong>反斜杠问题</strong><br>和大多数编程语言一样，正则使用 “\” 作为转义字符，这就可能赵成反斜杠困扰。假如需要匹配文本中的字符 “\”， 那么使用编程语言表示的正则表达式里将需要4个反斜杠 “\\“：前两个和后两个分别用于编程语言里转义成反斜杠，转换成两个反斜杠后再在正则表达式里转义成一个反斜杠。<br>Python里的原生字符串也可以很好的解决这个问题，上面例子可以使用 r”\“ 表示。同样，匹配一个数字的 “\d” 可以写成 r”\d”。</p>
<p></p><h3>Python Re模块</h3><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">re.compile(string[, flag])</div><div class="line">re.match(pattern, string[, flags])</div><div class="line">re.search(pattern, string[, flags])</div><div class="line">re.split(pattern, string[, maxsplit])</div><div class="line">re.findall(pattern, string[, flags])</div><div class="line">re.finditer(pattern, string[, flags])</div><div class="line">re.sub(pattern, repl, string[, count])</div><div class="line">re.subn(pattern, repl, string[, count])</div></pre></td></tr></table></figure><p></p>
<p>关于pattern的概念，pattern可以理解为一个匹配模式，为了获得这个模式，可以使用 re.compile() 方法：</p>
<pre><code>pattern = re.compile(r&apos;hello&apos;)
</code></pre><p>在参数中传入了原生字符串对象，通过compile方法编译生成一个pattern对象，就可以利用这个对象来进行进一步的匹配。<br>关于参数flags含义，参数flag是匹配模式，取值可以使用按位或运算符 ‘|’ 表示同时生效，比如 re.I|re.M<br>可选值有：</p>
<pre><code>- re.I(全拼: IGNORECASE): 忽略大小写
- re.M(全拼: MULTILINE): 多行模式，改变&apos;^&apos;和&apos;$&apos;的行为
- re.S(全拼: DOTALL): 点任意匹配模式，改变&apos;.&apos;的行为
- re.L(全拼: LOCALE): 使预定字符类 \w \W \b \B \s \S 取决于当前区域设定
- re.U(全拼: UNICODE): 使预定字符类 \w \W \b \B \s \S 取决与unicode定义的字符属性
- re.X(全拼: BERBOSE): 详细模式。这个模式下正则表达式可以是多行，忽略空白字符，并可以加入注释
</code></pre><p><strong>1) re.match(pattern, string[, flags])</strong><br>这个方法将会从string(需要匹配的字符串)的开头开始，尝试匹配pattern，一直向后匹配，如果遇到无法匹配的字符，立即返回None，如果匹配未结束已经达到string的末尾，也会返回None。两个结果均表示匹配失败，否则匹配pattern成功，同时匹配终止，不再对string向后匹配。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"># -*- coding: utf-8 -*-</div><div class="line">import re</div><div class="line"></div><div class="line">pattern = re.compile(r&apos;hello&apos;)</div><div class="line"></div><div class="line">result1 = re.match(pattern, &apos;hello&apos;)</div><div class="line">result2 = re.match(pattern, &apos;helloo World!&apos;)</div><div class="line">result3 = re.match(pattern, &apos;helo World!&apos;)</div><div class="line">result4 = re.match(pattern, &apos;hello World!&apos;)</div><div class="line"></div><div class="line">if result1:</div><div class="line">    print result1.group()</div><div class="line">else:</div><div class="line">    print &apos;1匹配失败！&apos;</div><div class="line"></div><div class="line">if result2:</div><div class="line">    print result2.group()</div><div class="line">else:</div><div class="line">    print &apos;2匹配失败！&apos;</div><div class="line"></div><div class="line">if result3:</div><div class="line">    print result3.group()</div><div class="line">else:</div><div class="line">    print &apos;3匹配失败！&apos;</div><div class="line"></div><div class="line">if result4:</div><div class="line">    print result4.group()</div><div class="line">else:</div><div class="line">    print &apos;4匹配失败！&apos;</div></pre></td></tr></table></figure></p>
<p>运行结果：</p>
<pre><code>hello
hello
3匹配失败！
hello
</code></pre><p>属性：</p>
<pre><code>1.string: 匹配时使用的文本。
2.re: 匹配时使用的Pattern对象。
3.pos: 文本中正则表达式开始搜索的索引。值与Pattern.match()和Pattern.seach()方法的同名参数相同。
4.endpos: 文本中正则表达式结束搜索的索引。值与Pattern.match()和Pattern.seach()方法的同名参数相同。
5.lastindex: 最后一个被捕获的分组在文本中的索引。如果没有被捕获的分组，将为None。
6.lastgroup: 最后一个被捕获的分组的别名。如果这个分组没有别名或者没有被捕获的分组，将为None。
</code></pre><p>方法：</p>
<pre><code>1.group([group1, …]):
获得一个或多个分组截获的字符串；指定多个参数时将以元组形式返回。group1可以使用编号也可以使用别名；编号0代表整个匹配的子串；不填写参数时，返回group(0)；没有截获字符串的组返回None；截获了多次的组返回最后一次截获的子串。
2.groups([default]):
以元组形式返回全部分组截获的字符串。相当于调用group(1,2,…last)。default表示没有截获字符串的组以这个值替代，默认为None。
3.groupdict([default]):
返回以有别名的组的别名为键、以该组截获的子串为值的字典，没有别名的组不包含在内。default含义同上。
4.start([group]):
返回指定的组截获的子串在string中的起始索引（子串第一个字符的索引）。group默认值为0。
5.end([group]):
返回指定的组截获的子串在string中的结束索引（子串最后一个字符的索引+1）。group默认值为0。
6.span([group]):
返回(start(group), end(group))。
7.expand(template):
将匹配到的分组代入template中然后返回。template中可以使用\id或\g、\g引用分组，但不能使用编号0。\id与\g是等价的；但\10将被认为是第10个分组，如果你想表达\1之后是字符’0’，只能使用\g0。
</code></pre><p>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"># -*- coding:utf-8 -*-</div><div class="line"># 一个简单的match实例</div><div class="line"></div><div class="line">import re</div><div class="line">m = re.match(r&apos;(\w+) (\w+)(?P&lt;sign&gt;.*)&apos;, &apos;hello world!&apos;)</div><div class="line"></div><div class="line">print &quot;m.string:&quot;, m.string</div><div class="line">print &quot;m.re:&quot;, m.re</div><div class="line">print &quot;m.pos:&quot;, m.pos</div><div class="line">print &quot;m.endpos:&quot;, m.endpos</div><div class="line">print &quot;m.lastindex:&quot;, m.lastindex</div><div class="line">print &quot;m.lastgroup:&quot;, m.lastgroup</div><div class="line">print &quot;m.group():&quot;, m.group()</div><div class="line">print &quot;m.group(1,2):&quot;, m.group(1, 2)</div><div class="line">print &quot;m.groups():&quot;, m.groups()</div><div class="line">print &quot;m.groupdict():&quot;, m.groupdict()</div><div class="line">print &quot;m.start(2):&quot;, m.start(2)</div><div class="line">print &quot;m.end(2):&quot;, m.end(2)</div><div class="line">print &quot;m.span(2):&quot;, m.span(2)</div><div class="line">print r&quot;m.expand(r&apos;\g \g\g&apos;):&quot;, m.expand(r&apos;\2 \1\1&apos;)</div></pre></td></tr></table></figure></p>
<p>输出结果：<br><img src="http://wx3.sinaimg.cn/mw690/ee20bc6cgy1fkewgsl5f9j20eo08djrt.jpg" alt="此处输入图片的描述"></p>
<p><strong>2) re.search(pattern, string[, flags])</strong></p>
<p>search方法和match方法很类似，区别在于match()函数只检测re是不是在string的开始位置匹配，search()会扫描整个string查找匹配，match()只有在0位置匹配成功的话才有返回，如果不是开始匹配成功的话，match()就会返回None. 同样，search方法的返回对象同样match()放回对象的方法和属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">import re</div><div class="line"></div><div class="line">pattern = re.compile(r&apos;world&apos;)</div><div class="line"></div><div class="line">match = re.search(pattern, &apos;hello world!&apos;)</div><div class="line">if match:</div><div class="line">    print match.group()</div></pre></td></tr></table></figure></p>
<p>输出结果：</p>
<pre><code>world
</code></pre><p><strong>3) re.split(pattern, string[, maxsplit])</strong></p>
<p>按照能够匹配的子串将string分割后返回列表。maxsplit用于指定最大分割次数，不指定将全部分割。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">import re</div><div class="line"></div><div class="line">pattern = re.compile(r&apos;\d+&apos;)</div><div class="line">print re.split(pattern, &apos;one1two2three3four4&apos;)</div></pre></td></tr></table></figure></p>
<p>输出结果：</p>
<pre><code>[&apos;one&apos;, &apos;two&apos;, &apos;three&apos;, &apos;four&apos;]
</code></pre><p><strong>4) re.findall(pattern, string[, flags])</strong></p>
<p>搜索string，以列表形式返回全部能匹配的子串。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">import re</div><div class="line"></div><div class="line">pattern = re.compile(r&apos;\d+&apos;)</div><div class="line">print re.findall(pattern, &apos;one1two2three3four4&apos;)</div></pre></td></tr></table></figure></p>
<p>输出结果：</p>
<pre><code>[&apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;]
</code></pre><p><strong>5) re.finditer(pattern, string[, flags])</strong></p>
<p>搜索string，返回一个顺序访问每一个匹配结果（match对象）的迭代器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">import re</div><div class="line"></div><div class="line">pattern = re.compile(r&apos;\d+&apos;)</div><div class="line">for m in re.finditer(pattern, &apos;one1two2three3four4&apos;):</div><div class="line">    print m.group()</div></pre></td></tr></table></figure></p>
<p>输出结果：</p>
<pre><code>1
2
3
4
</code></pre><p><strong>6) re.sub(pattern, repl, string[, count])</strong></p>
<p>使用repl替换string中的每一个匹配的子串后返回替换后的字符串。<br>当repl是一个字符串时，可以使用\id或\g、\g引用分组，但不能使用编号0<br>当repl是一个方法时，这个方法应当只接受一个参数（match参数），并返回一个字符串用于替换（返回的字符串中不能再引用分组）。<br>count用于指定最多替换次数，不指定时全部替换。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">import re</div><div class="line"></div><div class="line">pattern = re.compile(r&apos;(\w+) (\w+)&apos;)</div><div class="line">s = &apos;i say, hello world!&apos;</div><div class="line"></div><div class="line">print re.sub(pattern, r&apos;\2 \1&apos;, s)</div><div class="line"></div><div class="line">def func(m):</div><div class="line">    return m.group(1).title() + &apos; &apos; + m.group(2).title()</div><div class="line"></div><div class="line">print re.sub(pattern, func, s)</div></pre></td></tr></table></figure></p>
<p>输出结果：</p>
<pre><code>say i, world hello!
I Say, Hello World!
</code></pre><p><strong>7) re.subn(pattern, repl, string[, count])</strong><br>返回(sub(repl, string[, count]), 替换次数)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">import re</div><div class="line"></div><div class="line">pattern = re.compile(r&apos;(\w+) (\w+)&apos;)</div><div class="line">s = &apos;i say, hello world!&apos;</div><div class="line"></div><div class="line">print re.subn(pattern, r&apos;\2 \1&apos;, s)</div><div class="line"></div><div class="line">def func(m):</div><div class="line">    return m.group(1).title() + &apos; &apos; + m.group(2).title()</div><div class="line"></div><div class="line">print re.subn(pattern, func, s)</div></pre></td></tr></table></figure></p>
<p>输出结果：</p>
<pre><code>(&apos;say i, world hello!&apos;, 2)
(&apos;I say, Hello World!&apos;, 2)
</code></pre><p></p><h3>Python Re模块的另一种使用方式</h3><br>上面介绍了七个工具，调用都是re.match, re.search这样的方式。其实还有另外一种调用方式，可以通过 pattern.match, pattern.search调用，这样调用便不用将pattern作为第一个参数传入了，当然，随便使用哪一种调用方式都可以。<br>函数API列表：<p></p>
<pre><code>match(string[, pos[, endpos]]) | re.match(pattern, string[, flags])
search(string[, pos[, endpos]]) | re.search(pattern, string[, flags])
split(string[, maxsplit]) | re.split(pattern, string[, maxsplit])
findall(string[, pos[, endpos]]) | re.findall(pattern, string[, flags])
finditer(string[, pos[, endpos]]) | re.finditer(pattern, string[, flags])
sub(repl, string[, count]) | re.sub(pattern, repl, string[, count])
subn(repl, string[, count]) |re.sub(pattern, repl, string[, count])
</code></pre><p>掌握了这些，就可以开始去进行实战训练了！<br><img src="http://wx3.sinaimg.cn/mw690/ee20bc6cgy1fk82dc6vp3j20k007nmxw.jpg" alt="此处输入图片的描述"></p>
</article></main></body></html>